#!/bin/bash
#
# This script runs tail -f on the given input files and
# sends the output to a given/ network port

DEFAULT_PIPE=stream.pipe
DEFAULT_PORT=50000

usage () {
echo "$(basename "$0") [-h] [-n PIPE] [-p PORT] <files> -- Continuously send file content to network port

Options:
    -h  show this help text
    -n  named pipe to use (default: $DEFAULT_PIPE)
    -p  network port (default: $DEFAULT_PORT)
    <files> files to use"
exit
}

# Call usage if too few arguments are supplied
[[ $# -lt 1 ]] && usage

# Parse arguments
while [[ $# -gt 0 ]]; do
    opt="$1"
    case $opt in
        -h)
            usage
            ;;
        -n)
            pipe="$2"
            shift
            ;;
        -p)
            port="$2"
            shift
            ;;
        *)
            files="$@"
            break
            ;;
    esac
    shift
done

# Files cannot be empty
if [ "$files" == "" ]; then
    echo "No files given"
    usage
fi
# Set pipe and port
pipe=${pipe:-$DEFAULT_PIPE}
port=${port:-$DEFAULT_PORT}

echo "Starting $(basename "$0")"
echo "Using pipe: $pipe"
echo "Using network port: $port"
echo "Using files: $files"

# Remove pipe if it exists
if [ -p "$pipe" ]; then
    rm -f $pipe
fi
# Create pipe
echo "Creating pipe"
mkfifo $pipe

# Wait until all input files exist
echo "Sleeping until all input files exist"
for f in $files; do
    while ! [ -f $f ]; do
        sleep 1
    done
done
echo "All files present - starting streaming"

#(tail -n 1 -f $files | nc localhost $port ) &
nc localhost $port < $pipe &
tail -f $files >> $pipe &

# stop pipeline on sigterm/sigint
trap "echo 'Received SIGTERM/SIGINT - exiting'; echo 'EOF' >> $pipe; rm -f $pipe; pkill -P $$" SIGTERM SIGINT

wait
