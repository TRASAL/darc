#!/bin/bash
#
# This script runs tail -F on the given input files and
# sends the output to a network port through a named pipe

DEFAULT_PIPE=stream.pipe
DEFAULT_PORT=50000

usage () {
echo "$(basename "$0") [-h] [-n PIPE] [-p PORT] <files> -- Continuously send file content to network port

Options:
    -h  show this help text
    -n  named pipe to use (default: $DEFAULT_PIPE)
    -p  network port (default: $DEFAULT_PORT)
    <files> files to use"
exit
}

# Call usage if too few arguments are supplied
[[ $# -lt 1 ]] && usage

# Parse arguments
while [[ $# -gt 0 ]]; do
    opt="$1"
    case $opt in
        -h)
            usage
            ;;
        -n)
            pipe="$2"
            shift
            ;;
        -p)
            port="$2"
            shift
            ;;
        *)
            files="$@"
            break
            ;;
    esac
    shift
done

# Files cannot be empty
if [ "$files" == "" ]; then
    echo "No files given"
    usage
fi
# Set pipe and port
pipe=${pipe:-$DEFAULT_PIPE}
port=${port:-$DEFAULT_PORT}

echo "Starting $(basename "$0")"
echo "Using pipe: $pipe"
echo "Using network port: $port"
echo "Using files: $files"

# Remove pipe if it exists
if [ -p "$pipe" ]; then
    rm -f $pipe
fi
# Create pipe
echo "Creating pipe"
mkfifo $pipe

echo "Starting streaming"
tail -F $files >> $pipe &
echo "Opening network connection"
nc localhost $port < $pipe &
echo "Running"

# stop pipeline on sigterm/sigint
trap "echo 'Received SIGTERM/SIGINT - exiting'; echo 'EOF' >> $pipe; pkill -P $$; rm -f $pipe" SIGTERM SIGINT

wait
